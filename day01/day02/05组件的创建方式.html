<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- 导入vue.js -->
    <script src="../day02/lib/vue.js"> </script>
</head>
<body>
    <!-- 将来new的vue实例会控制元素中所有内容 -->
    <!-- vue实例控制的这个元素区域就是我们的 V -->
    <div id="app">
        <!-- 如果要使用组件，直接把组件的名称，以html标签的形式引入到页面中，即可 -->
        <my-com1></my-com1>
        
        <mycom1></mycom1>
        <my-com2></my-com2>
        <mycom3></mycom3>
    </div>

    <!-- 在#app的外层，使用template定义模板元素 -->
    <template id="tmpl">
        <h5>我是Jerry</h5>
    </template>
    <script>
        //1.使用vue.extend来创建全局的vue组件
        var com1 = Vue.extend({
            template:'<h1>这是测试</h1>'//通过template属性，制定了组件要展示的html结构
        })
        //2.使用Vue.component('组件的名称',创建出来的组件模板对象)
        //如果使用Vue.component定义全局组建的时候，组件名称使用驼峰命名。则在引用组建的时候，把大写的驼峰改成小写的字母。或者不用驼峰直接用名字
        Vue.component('myCom1',com1)


        //3.将上面两中方法结合一下,我还发现，两种命名方式不同可以是不同的组件,template只能有一个根元素
        Vue.component('mycom1',Vue.extend({
            template:'<h2>你好啊</h2>'
        }))
        //上面的可以简写为：
        Vue.component('myCom2',{
            template:"<h2>请问</h2><h3>你谁阿？</h3>"
        })


        //4.在被控制的外层定义模板元素
        Vue.component('mycom3',{
            template:'#tmpl'
        })






        // 创建一个vue的实例
        //当我们导入包后。浏览器内存中多个vue构造函数
        // 注意：我们new 出来的这个vm 对象就是我们的VM
        var vm = new Vue({
            el: '#app', //表示当前我们new的实例要控制页面上的那个区
            //这里的data就是MVVM中的M，专门用来保存数据
            data:{//data数学中，存放的是el中要用到的数据
                msg:'欢迎学习vue'//通过vue提供的指令很方便地渲染数据，不手动操作dom元素，不提倡手动操作dom
            },
            components:{//定义实例内部私有组件

            }
        })
    </script>
</body>
</html>